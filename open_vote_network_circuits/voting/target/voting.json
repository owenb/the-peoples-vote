{"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","hash":"15477502321887788603","abi":{"parameters":[{"name":"vote_degree","type":{"kind":"field"},"visibility":"private"},{"name":"public_generator","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_vote","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"fn main(vote_degree: Field,\n        public_generator: pub Field,\n        encrypted_vote: pub Field) {\n    assert(encrypted_vote == pow_254(public_generator, vote_degree));\n    assert(vote_degree * (1 - vote_degree) == 0);\n}\n\npub fn pow_254(base: Field, exponent: Field) -> Field {\n    let mut r: Field = 1;\n    let b: [u1; 254] = exponent.to_le_bits();\n\n    for i in 1..254+1 {\n        r *= r;\n        r = (b[254 - i] as Field) * (r * base) + (1 - b[254 - i] as Field) * r;\n    }\n    r\n}\n\n\n#[test]\nfn test_main() {\n    let generator = 3;\n    let encrypted = 3 * 3;\n    main(2, generator, encrypted);\n}\n\n#[test]\nfn test_zero() {\n    let r = 21888242871839275222246405745257275088548364400416034343698204186575808495616 + 1;\n    let generator = 3;\n    let encrypted = 1;\n    main(r, generator, encrypted);\n}\n\n","path":"/home/user/Projects/PolkaVote/frontend/open_vote_network_circuits/voting/src/main.nr"}},"names":["main"],"brillig_names":["directive_to_radix"]}