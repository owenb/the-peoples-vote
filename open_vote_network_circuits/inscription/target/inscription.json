{"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","hash":"15106137583308675625","abi":{"parameters":[{"name":"random_value","type":{"kind":"field"},"visibility":"private"},{"name":"generator","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_random_value","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"fn main(random_value: Field,\n        generator: pub Field,\n        encrypted_random_value: pub Field) {\n\n    let expected = pow_254(generator, random_value);\n    assert(encrypted_random_value == expected);\n}\n\npub fn pow_254(base: Field, exponent: Field) -> Field {\n    let mut r: Field = 1;\n    let b: [u1; 254] = exponent.to_le_bits();\n\n    for i in 1..254+1 {\n        r *= r;\n        r = (b[254 - i] as Field) * (r * base) + (1 - b[254 - i] as Field) * r;\n    }\n    r\n}\n\n\n#[test]\nfn test_main() {\n    let generator = 3;\n    let encrypted = 3 * 3;\n    main(2, generator, encrypted);\n}\n\n#[test]\nfn test_zero() {\n    let r = 21888242871839275222246405745257275088548364400416034343698204186575808495616 + 1;\n    let generator = 3;\n    let encrypted = 1;\n    main(r, generator, encrypted);\n}\n\n","path":"/home/user/Projects/PolkaVote/frontend/open_vote_network_circuits/inscription/src/main.nr"}},"names":["main"],"brillig_names":["directive_to_radix"]}